'use client';
import React, { useState, useEffect, useRef } from "react";
import Image from "next/image";
import { Box, Button, Typography, Collapse, Input, Select } from "@mui/material";
import { useAtom } from "jotai";
import { appAtom } from "@/store/AppStore";
import { StyledCard } from "@/components/Cards/Cards";
import { readContract } from "wagmi/actions";
import { useConfig, useWriteContract } from "wagmi";
import { TExistingLCertProps, TOrg, TLCert, TIssueLCertParams } from "@/types";
import { Contracts } from "@/contracts";
import { Address } from "viem";
import { useFormik } from "formik";
import * as yup from "yup";
import createCertificate, { certData, dataURLtoBlob } from "./createCertificate";
import certbg1 from '../../../../public/images/certBackrounds/6.png'
import { NFTStorage, File } from "nft.storage"


export default function ExistingOrgsSection(props: TExistingLCertProps) {
  const [appState, setAppState] = useAtom(appAtom);
  const [lCerts, setLCerts] = useState<TLCert[]>([]);
  const [expandedIndex, setExpandedIndex] = useState<number | null>(null);
  const [chosenCertBackground, setChosenCertBackground] = useState<string>("");
  const [certificateSrc, setCertificateSrc] = useState<string|null>("")
  const config = useConfig();
  const { writeContract: writeIssueCert, error } = useWriteContract();
  const instituteRef = useRef(null);
  const [url, seturl] = useState<string>('')


  // ADD CREATE CANVAS HERE AND FIX THE LAYOUT OF THE FORM TO FIT WHAT YOU HAD BEFORE
  // TOKEN URI IS THE IPFS LINK, SO YOU NEED TO UPLOAD THE IMAGE TO IPFS AND GET THE LINK
  // THEN YOU CAN USE THAT LINK TO CREATE THE CERTIFICATE, USERS SHOULDNT TYPE IN TOKEN URI
  // IT SHOULD BE GENERATED BY THE APP
  // ALSO YOU NEED TO ADD THE FUNCTION THAT GENERATES THE CERTIFICATE

  /*
    Data That the metadata/image should have:
    - Name of the certificate
    - Name of the organization
    - Date of issue
    - Date of expiration
    - Name of the recipient (first name and last name)
    - Address of the recipient

    data type ?
    type = {
      firstName: string,
      lastName: string,
      certName: string,
      remarks: string,
      issuedTo: string,
      orgName: string,
      description: string,
      dateIssued: string,
      dateExpired: string,
    }
  */

  const { writeContract:mintCertificate, error:mintCertificateError, isSuccess :mintCertificateSuccess } = useWriteContract()

  const issueLCertForm = useFormik({
    initialValues: {
      firstName: "",
      lastName: "",
      certName: expandedIndex ? lCerts[expandedIndex as number].certName : "yyyy",
      remarks: "",
      issuedTo: "",
      orgName: props.org?.orgName || "",
      description: "",
      dateIssued: new Date().toISOString(),
      expInDays: "",
      selectedBackground: "",
    },
    validationSchema: yup.object({
      firstName: yup.string().required("Required"),
      lastName: yup.string().required("Required"),
      certName: yup.string().required("Required"),
      remarks: yup.string().required("Required"),
      issuedTo: yup.string().required("Required"),
      orgName: yup.string().required("Required"),
      description: yup.string().required("Required"),
      // dateIssued: yup.string().required("Required"),
      expInDays: yup.string().required("Required"),
      // selectedBackground: yup.string().required("Required"),
    }),
    onSubmit: async (values: any) => {
      values.certName = lCerts[expandedIndex as number].certName;
      console.log(values);
      
      mintnfthandler(event, url, values.expInDays);    // this function will mint the certificate with the metadata link as tokenURI
      
      const tokenURI = `ipfs://${url}`;
      console.log(tokenURI, "tokenURI max");
      
      
      mintCertificate({
        abi: Contracts.Cert.abi,
        address: '0xE649e4A5f1F269685d09b1245bE829039fa3781e',
        functionName: "mint",
        args: [
          values.issuedTo, 
          tokenURI,
          values.expInDays,
        ],
      });
      console.log(mintCertificateError, "mintCertificateError");
      console.log(mintCertificateSuccess, "mintCertificateSuccess");
    }

    // values.issuedTo,
    // tokenURI,
    // values.expInDays,

    // values.issuedTo, works
    // values.expInDays,
    // tokenURI,

    // tokenURI,
    // values.issuedTo,
    // values.expInDays,

    // tokenURI,
    // values.expInDays,
    // values.issuedTo,

    // values.expInDays,
    // values.issuedTo,
    // tokenURI,

    // values.expInDays,
    // tokenURI,
    // values.issuedTo,
    // abc
    // acb
    // bac
    // bca
    // cab
    // cba
      

      //Function to mint the certificate with the metadata link as tokenURI, reciever address and expiry in days
      // create Image here and upload to IPFS 

      // Get image ipfs link and create metadata file with the data and the link as image

      // upload metadata file to IPFS and get the link

      // create the certificate with the metadata link as tokenURI
    
    })
  

  // const issueLCertForm = useFormik({
  //   initialValues: {
  //     to: "" as Address,
  //     tokenURI: "",
  //     expInDays: 0,
  //   },
  //   validationSchema: yup.object({
  //     to: yup.string().required("Required"),
  //     tokenURI: yup.string().required("Required"),
  //     expInDays: yup.number().required("Required").min(1),
  //   }),
  //   onSubmit: async (values: TIssueLCertParams) => {
  //     console.log(values);
  //     await writeIssueCert({
  //       abi: Contracts.Cert.abi,
  //       address: lCerts[expandedIndex as number].certAddress,
  //       functionName: "mint",
  //       args: [values.to, values.tokenURI, values.expInDays],
  //     });
  //   }
  // });



  const generateCertificate = async (): Promise<string | null> => {
    const instituteValue: string = issueLCertForm.getFieldProps("orgName").value;
    try {
        const certData: certData = {
            Organization: issueLCertForm.getFieldProps("orgName").value,
            StudentName: issueLCertForm.getFieldProps("firstName").value + " " + issueLCertForm.getFieldProps("lastName").value,
            CertificateName: issueLCertForm.getFieldProps("certName").value,
            Duration: issueLCertForm.getFieldProps("expInDays").value, // Assuming validity is a string that needs to be parsed as an integer
            certBg: certbg1.src
        };
        console.log(certData, " for function call ");

        const imageSrc = await createCertificate(certData);
        // console.log("settled the cert src", imageSrc);
        return imageSrc; // Directly return the generated src
    } catch (error) {
        console.error(error);
        return null;
    }
};

  const createCanvas=async(event: React.FormEvent)=>{
    event.preventDefault();
    const files = await generateCertificate(); // This will return the image src
    setCertificateSrc(files)

    try{
      const blobfile = files && dataURLtoBlob(files); // This will convert the image src to a blob file
      if (blobfile) {
        const ipnft = await uploadImage(blobfile); // This will upload the image to IPFS and return the IPFS link
        console.log(ipnft,"this is Ipnt");
      }
    }
    catch(err){
      console.log(err);
    }
  }


const uploadImage = async (imageData: Blob): Promise<string> => {
        // setloading(true)
        const nftstorage = new NFTStorage({ token: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweDAzM2Y5Mzc1ZEQ5ODY1YzhmN2FiODVENGRiRTM3NDhERWI4NTljRkYiLCJpc3MiOiJuZnQtc3RvcmFnZSIsImlhdCI6MTY4NTc3MTE1MDk5NiwibmFtZSI6IlBBUkszIn0.eHLoAl-RBIxAqXmHm_KTQ553Ha-_18sZrnoxuXpGxMI` })

        // Check if instituteRef.current is not null
        const instituteValue: string = issueLCertForm.getFieldProps("orgName").value 

        // Send request to store image
        const { ipnft } = await nftstorage.store({ 
            image: new File([imageData], "image.jpeg", { type: "image/jpeg" }),
            name: issueLCertForm.getFieldProps("firstName").value,
            lastname: issueLCertForm.getFieldProps("lastName").value,
            certName: issueLCertForm.getFieldProps("certName").value,
            remarks: issueLCertForm.getFieldProps("remarks").value,
            validity: issueLCertForm.getFieldProps("expInDays").value,
            issuedTo: issueLCertForm.getFieldProps("issuedTo").value,
            issuerName: instituteValue,
            description: `
              ${issueLCertForm.getFieldProps("firstName").value} +' ' +
              ${issueLCertForm.getFieldProps("lastName").value} +' ' + 
              ${issueLCertForm.getFieldProps("certName").value} +' ' + 
              ${issueLCertForm.getFieldProps("remarks").value} +' ' + 
              ${issueLCertForm.getFieldProps("expInDays").value} +' ' + 
              ${issueLCertForm.getFieldProps("issuedTo").value} +' ' + 
              ${instituteValue} +' ' + 
              ${issueLCertForm.getFieldProps("description").value} +' ' + 
              ${issueLCertForm.getFieldProps("selectedBackground").value}`
        }) // This will store the image and return the IPFS link
 
        // Save the URL
        // const NFturl = `https://ipfs.io/ipfs/${ipnft}/metadata.json`
        seturl(ipnft)
        // Set showUploadAlert to true after uploadImage function is completed
        return ipnft
    }

    const mintnfthandler = async (e: any, ipnft: string, validitydate: string) => {
      e.preventDefault();
      // setloading(true)
      createCanvas(e);
      
      let nextTokenId: any = 1;
      let expireTimestamp = new Date().getTime() + (Number(validitydate) * 24 * 60 * 60 * 1000);
      const args = {
          reciever: issueLCertForm.getFieldProps("issuedTo").value,
          tokenId: nextTokenId + 1,
          tokenUri: ipnft, // need to set this up    -> done:settled this into createCanvas function(it will generate and print the ipnft token)
          _expire: Number(expireTimestamp),
      }
      console.log(args, " mint args")


      // HERE NEED TO CALL THE FUNCTION FROM SMART CONTRACT TO MINT THE CERTIFICATE 
      // ALSO HAVE TO PASS THE MESSAGE THROUGH TOAST WEATER IT IS SUCCESS OR FAILURE 
  }

  const fetchLCertsForOrg = async (org: TOrg) => {
    const lcertAddresses: any = await readContract(config, {
      abi: Contracts.CSIOrg.abi,
      address: org.orgAddress,
      functionName: "getCertificates",
      args: []
    });

    const promises = lcertAddresses?.map((certAddress: Address) => fetchLCertData(certAddress));
    const lcertData = await Promise.all(promises);
    setLCerts(lcertData);
  }

  const fetchLCertData = async (certAddress: Address): Promise<TLCert> => {
    const lCertNamePromise = readContract(config, {
      abi: Contracts.Cert.abi,
      address: certAddress,
      functionName: "name",
      args: []
    });

    const lCertSymbolPromise = readContract(config, {
      abi: Contracts.Cert.abi,
      address: certAddress,
      functionName: "symbol",
      args: []
    });

    const [lCertName, lCertSymbol] = await Promise.all([lCertNamePromise, lCertSymbolPromise]);

    return {
      certName: lCertName as string,
      certSymbol: lCertSymbol as string,
      certAddress: certAddress
    };
  }

  const handleToggle = (index: number) => {
    setExpandedIndex(expandedIndex === index ? null : index);
  };

  useEffect(() => {
    if (props.org) {
      fetchLCertsForOrg(props.org);
    }
  }, [props.org]);

  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        width: "100%",
        height: "100%",
      }}
    >
    {
      certificateSrc&&<Image width={100} height={100} src={certificateSrc} alt="Certificate" />
    } 
     {lCerts.map((lCert, index) => (
        <StyledCard key={index}>
          <Box
            sx={{
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              width: "100%",
            }}
          >
            <Typography variant="h6">Certificate Name: {lCert.certName}</Typography>
            <Button
              variant="contained"
              color="primary"
              onClick={() => handleToggle(index)}
            >
              {expandedIndex === index ? 'Close Form' : 'Issue a LCert'}
            </Button>
            <Collapse in={expandedIndex === index}>
              <Box sx={{ 
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                margin: 2
              }}>

                {/* First Name */}
                <Box>
                  <Input
                    id="firstName"
                    type="text"
                    placeholder="First Name"
                    security="true"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    {...issueLCertForm.getFieldProps("firstName")}
                  />
                  {issueLCertForm.touched.firstName && issueLCertForm.errors.firstName ? (
                    <div>{issueLCertForm.errors.firstName}</div>
                  ) : null}
                </Box>

                {/* Last Name */}
                <Box>
                  <Input
                    id="lastName"
                    type="text"
                    placeholder="Last Name"
                    security="true"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    {...issueLCertForm.getFieldProps("lastName")}
                  />
                  {issueLCertForm.touched.lastName && issueLCertForm.errors.lastName ? (
                    <div>{issueLCertForm.errors.lastName}</div>
                  ) : null}
                </Box>

                {/* Certificate Name */}
                <Box>
                  <Input
                    id="certName"
                    type="text"
                    security="true"
                    disabled
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    value={lCert.certName}  
                  />
                  
                </Box>

                {/* Remarks */}
                <Box>
                  <Input
                    id="remarks"
                    type="text"
                    placeholder="Remarks"
                    security="true"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    {...issueLCertForm.getFieldProps("remarks")}
                  />
                  {issueLCertForm.touched.remarks && issueLCertForm.errors.remarks ? (
                    <div>{issueLCertForm.errors.remarks}</div>
                  ) : null}
                </Box>

                {/* Issued To */}
                <Box>
                  <Input
                    id="issuedTo"
                    type="text"
                    placeholder="Issued To"
                    security="true"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    {...issueLCertForm.getFieldProps("issuedTo")}
                  />
                  {issueLCertForm.touched.issuedTo && issueLCertForm.errors.issuedTo ? (
                    <div>{issueLCertForm.errors.issuedTo}</div>
                  ) : null}

                </Box>

                {/* Organization Name */}
                <Box>
                  <Input
                    id="orgName"
                    type="text"
                    value={props.org?.orgName}
                    disabled
                    security="true"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                  />
                  {issueLCertForm.touched.orgName && issueLCertForm.errors.orgName ? (
                    <div>{issueLCertForm.errors.orgName}</div>
                  ) : null}
                </Box>

                {/* Description */}
                <Box>
                  <Input
                    id="description"
                    type="text"
                    placeholder="Description"
                    security="true"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    {...issueLCertForm.getFieldProps("description")}
                  />
                  {issueLCertForm.touched.description && issueLCertForm.errors.description ? (
                    <div>{issueLCertForm.errors.description}</div>
                  ) : null}
                </Box>
                
                {/* Exp in Days */}
                <Box>
                  <Input
                    id="expInDays"
                    type="text"
                    placeholder="Exp in Days"
                    security="true"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    {...issueLCertForm.getFieldProps("expInDays")}
                  />
                  {issueLCertForm.touched.expInDays && issueLCertForm.errors.expInDays ? (
                    <div>{issueLCertForm.errors.expInDays}</div>
                  ) : null}
                  
                </Box>

                {/* Background */}  
                {/* let user choose backrounds from pulic/image/certBackgrounds */}
                  
                {/* <Box>
                  <Select
                    id="selectedBackground"
                    sx={{
                      margin: 1,
                      borderRadius: "6px",
                      backgroundColor: "white",
                      color: "black",
                      width: "100%",
                      height: "40px",
                      padding: "10px",
                    }}
                    {...issueLCertForm.getFieldProps("selectedBackground")}
                  >
                    <option value="" disabled selected>Select Background</option>
                    <option value="background1">Background 1</option>
                    <option value="background2">Background 2</option>
                    <option value="background3">Background 3</option>
                    <option value="background4">Background 4</option>
                  </Select>
                  <Image src={chosenCertBackground} alt="Background" />
                  {issueLCertForm.touched.selectedBackground && issueLCertForm.errors.selectedBackground ? (
                    <div>{issueLCertForm.errors.selectedBackground}</div>
                  ) : null}

                </Box> */}
                <button onClick={(e)=>createCanvas(e)} >create canvas</button>
                <Button onClick={() => issueLCertForm.handleSubmit()} >Issue Certificate</Button>
              </Box>
            </Collapse>
          </Box>
        </StyledCard>
      ))}
    </Box>
  );
}
